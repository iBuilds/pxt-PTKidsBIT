<xml xmlns="https://developers.google.com/blockly/xml"><variables><variable id="Bl6Lh{e8-gb^Y6dt4|LK">Color_Background_Right</variable><variable id="$l)M4*3TDsBo`Dtup?dt">Color_Background_Left</variable></variables><comment id="g7fx;tXaH$-Q*=#G7PkE" data="0" x="0" y="0" h="160" w="480">Functions are mapped to blocks using various macros&#10;in comments starting with %. The most important macro&#10;is "block", and it specifies that a block should be&#10;generated for an **exported** function.</comment><block type="pxt-on-start" id="xRRgvHNlG#rZ^u`HECiY" x="10" y="10"><statement name="HANDLER"><block type="typescript_statement" id="VT}TkmF*hB*ol9%Ivk`Z" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="let right_motor_speed = 0" numlines="1" declaredvars="right_motor_speed"></mutation><next><block type="typescript_statement" id="t0]7Fxe}Byb{4VD={,,_" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="let left_motor_speed = 0" numlines="1" declaredvars="left_motor_speed"></mutation><next><block type="typescript_statement" id="jFK1Pg!p|utKD#zd#`do" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="let PD_Value = 0" numlines="1" declaredvars="PD_Value"></mutation><next><block type="typescript_statement" id="$X;Pn;4HZ[@SU9nWu+#@" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="let previous_error = 0" numlines="1" declaredvars="previous_error"></mutation><next><block type="typescript_statement" id="[P24I-!4YY;$vdU2IAZ/" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="let D = 0" numlines="1" declaredvars="D"></mutation><next><block type="typescript_statement" id="ecqmX2}V]70x=KeVOXex" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="let P = 0" numlines="1" declaredvars="P"></mutation><next><block type="typescript_statement" id="cUkmk_`T@,obb-P+EvGT" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="let error = 0" numlines="1" declaredvars="error"></mutation><next><block type="typescript_statement" id="s$qaw~B?x[QpSzL+xZ`f" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="let Last_Position = 0" numlines="1" declaredvars="Last_Position"></mutation><next><block type="typescript_statement" id="QvF6da[-^bM{YA{omd^u" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="let Line_Mode = 0" numlines="1" declaredvars="Line_Mode"></mutation><next><block type="variables_set" id="[3^{o[{pk`8weoDy*r%4"><field name="VAR" id="Bl6Lh{e8-gb^Y6dt4|LK">Color_Background_Right</field><value name="VALUE"><shadow type="math_number"><field name="NUM">0</field></shadow><block type="lists_create_with" id="+?ZR9mNQ0B#gce1rw#ad"><mutation items="0"/></block></value><next><block type="typescript_statement" id="TGHe_AEmH,IjC;%vXn)w" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="let Color_Line_Right: number[] = []" numlines="1" declaredvars="Color_Line_Right"></mutation><next><block type="variables_set" id="+36jM^;MYxb8`/naXGzb"><field name="VAR" id="$l)M4*3TDsBo`Dtup?dt">Color_Background_Left</field><value name="VALUE"><shadow type="math_number"><field name="NUM">0</field></shadow><block type="lists_create_with" id="By9,:P.hof;iV}o1:?C7"><mutation items="0"/></block></value><next><block type="typescript_statement" id=",`Lh;M}e6AtO;xVncrMj" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="let Color_Line_Left: number[] = []" numlines="1" declaredvars="Color_Line_Left"></mutation><next><block type="typescript_statement" id="8eJfPT9/{4?ZH$q,+RdX" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="let Color_Background: number[] = []" numlines="1" declaredvars="Color_Background"></mutation><next><block type="typescript_statement" id="%u%Y{y7:eKN*.mnvbNi;" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="let Color_Line: number[] = []" numlines="1" declaredvars="Color_Line"></mutation><next><block type="typescript_statement" id="c?g-^DLn4p9yTT*Q%}=)" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="let LED_PIN = 0" numlines="1" declaredvars="LED_PIN"></mutation><next><block type="typescript_statement" id="jOpY*QP8:PgjE*E%e2WD" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="let Num_Sensor = 0" numlines="1" declaredvars="Num_Sensor"></mutation><next><block type="typescript_statement" id="@j3|M7C:fPeEq#p}?9p*" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="let Sensor_Right: number[] = []" numlines="1" declaredvars="Sensor_Right"></mutation><next><block type="typescript_statement" id="^^8xd3m:6u)#nnfajvDk" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="let Sensor_Left: number[] = []" numlines="1" declaredvars="Sensor_Left"></mutation><next><block type="typescript_statement" id="32SDBhMqjh,B5gcI|z?I" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="let Sensor_PIN: number[] = []" numlines="1" declaredvars="Sensor_PIN"></mutation><next><block type="typescript_statement" id="9/32=rCuV%%4%FtQ@NH1" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="enum Motor_Write {" line1="    //% block=&quot;1&quot;" line2="    Motor_1," line3="    //% block=&quot;2&quot;" line4="    Motor_2" line5="}" numlines="6"></mutation><next><block type="typescript_statement" id="~*Zd/I6M4w@0-j0ra|+F" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="enum _Turn {" line1="    //% block=&quot;Left&quot;" line2="    Left," line3="    //% block=&quot;Right&quot;" line4="    Right" line5="}" numlines="6"></mutation><next><block type="typescript_statement" id="TYM(BYu;J[9*M^94my^L" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="enum _Spin {" line1="    //% block=&quot;Left&quot;" line2="    Left," line3="    //% block=&quot;Right&quot;" line4="    Right" line5="}" numlines="6"></mutation><next><block type="typescript_statement" id="QjJ}*30x%f,Y|RbjVu(1" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="enum Servo_Write {" line1="    //% block=&quot;P8&quot;" line2="    P8," line3="    //% block=&quot;P12&quot;" line4="    P12" line5="}" numlines="6"></mutation><next><block type="typescript_statement" id="i=vXf=7%h;Iz-/L[%$,9" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="enum ADC_Read {" line1="    //% block=&quot;0&quot;" line2="    ADC0 = 0x84," line3="    //% block=&quot;1&quot;" line4="    ADC1 = 0xC4," line5="    //% block=&quot;2&quot;" line6="    ADC2 = 0x94," line7="    //% block=&quot;3&quot;" line8="    ADC3 = 0xD4," line9="    //% block=&quot;4&quot;" line10="    ADC4 = 0xA4," line11="    //% block=&quot;5&quot;" line12="    ADC5 = 0xE4," line13="    //% block=&quot;6&quot;" line14="    ADC6 = 0xB4," line15="    //% block=&quot;7&quot;" line16="    ADC7 = 0xF4" line17="}" numlines="18"></mutation><next><block type="typescript_statement" id="=0JPnq-??fF0=e19yqN{" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="enum Find_Line {" line1="    //% block=&quot;Left&quot;" line2="    Left," line3="    //% block=&quot;Center&quot;" line4="    Center," line5="    //% block=&quot;Right&quot;" line6="    Right" line7="}" numlines="8"></mutation><next><block type="typescript_statement" id="pCwte4B7arj;%1O[WP*c" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="enum LED_Pin {" line1="    //% block=&quot;Disable&quot;" line2="    Disable," line3="    //% block=&quot;P1&quot;" line4="    P1," line5="    //% block=&quot;P2&quot;" line6="    P2," line7="    //% block=&quot;P8&quot;" line8="    P8," line9="    //% block=&quot;P12&quot;" line10="    P12" line11="}" numlines="12"></mutation><next><block type="typescript_statement" id="2Rhe{i5(#a)Eg-P#l~KC" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="enum Turn_Line {" line1="    //% block=&quot;Left&quot;" line2="    Left," line3="    //% block=&quot;Right&quot;" line4="    Right" line5="}" numlines="6"></mutation><next><block type="typescript_statement" id="{D^go147G~*)Vl7-Xq61" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace PTKidsBIT {" line1="&#9;//% group=&quot;Motor Control&quot;" line2="    /**" line3="     * Stop all Motor" line4="     */" line5="    //% block=&quot;Motor Stop&quot;" line6="    export function motorStop():void {" line7="        pins.digitalWritePin(DigitalPin.P13, 1)" line8="        pins.analogWritePin(AnalogPin.P14, 0)" line9="        pins.digitalWritePin(DigitalPin.P15, 1)" line10="        pins.analogWritePin(AnalogPin.P16, 0)" line11="    }" line12="" line13="    //% group=&quot;Motor Control&quot;" line14="    /**" line15="     * Spin the Robot to Left or Right. The speed motor is adjustable between 0 to 100." line16="     */" line17="    //% block=&quot;Spin %_Spin|Speed %Speed&quot;" line18="    //% speed.min=0 speed.max=100" line19="    export function Spin(spin: _Spin, speed: number): void {" line20="        speed = pins.map(speed, 0, 100, 0, 1023)" line21="        " line22="        if (spin == _Spin.Left) {" line23="            pins.digitalWritePin(DigitalPin.P13, 0)" line24="            pins.analogWritePin(AnalogPin.P14, speed)" line25="            pins.digitalWritePin(DigitalPin.P15, 1)" line26="            pins.analogWritePin(AnalogPin.P16, speed)" line27="        }" line28="        else if (spin == _Spin.Right) {" line29="            pins.digitalWritePin(DigitalPin.P13, 1)" line30="            pins.analogWritePin(AnalogPin.P14, speed)" line31="            pins.digitalWritePin(DigitalPin.P15, 0)" line32="            pins.analogWritePin(AnalogPin.P16, speed)" line33="        }" line34="    }" line35="" line36="    //% group=&quot;Motor Control&quot;" line37="    /**" line38="     * Turn the Robot to Left or Right. The speed motor is adjustable between 0 to 100." line39="     */" line40="    //% block=&quot;Turn %_Turn|Speed %Speed&quot;" line41="    //% speed.min=0 speed.max=100" line42="    export function Turn(turn: _Turn, speed: number): void {" line43="        speed = pins.map(speed, 0, 100, 0, 1023)" line44="        " line45="        if (turn == _Turn.Left) {" line46="            pins.digitalWritePin(DigitalPin.P13, 0)" line47="            pins.analogWritePin(AnalogPin.P14, 0)" line48="            pins.digitalWritePin(DigitalPin.P15, 1)" line49="            pins.analogWritePin(AnalogPin.P16, speed)" line50="        }" line51="        else if (turn == _Turn.Right) {" line52="            pins.digitalWritePin(DigitalPin.P13, 1)" line53="            pins.analogWritePin(AnalogPin.P14, speed)" line54="            pins.digitalWritePin(DigitalPin.P15, 0)" line55="            pins.analogWritePin(AnalogPin.P16, 0)" line56="        }" line57="    }" line58="" line59="    //% group=&quot;Motor Control&quot;" line60="    /**" line61="     * Control motors speed both at the same time. The speed motors is adjustable between -100 to 100." line62="     */" line63="    //% block=&quot;Motor1 %Motor1|Motor2 %Motor2&quot;" line64="    //% speed1.min=-100 speed1.max=100" line65="    //% speed2.min=-100 speed2.max=100" line66="    export function motorGo(speed1: number, speed2: number): void {" line67="        speed1 = pins.map(speed1, -100, 100, -1023, 1023)" line68="        speed2 = pins.map(speed2, -100, 100, -1023, 1023)" line69="" line70="        if (speed1 &lt; 0) {" line71="            pins.digitalWritePin(DigitalPin.P13, 0)" line72="            pins.analogWritePin(AnalogPin.P14, -speed1)" line73="        }" line74="        else if (speed1 &gt;= 0) {" line75="            pins.digitalWritePin(DigitalPin.P13, 1)" line76="            pins.analogWritePin(AnalogPin.P14, speed1)" line77="        }" line78="" line79="        if (speed2 &lt; 0) {" line80="            pins.digitalWritePin(DigitalPin.P15, 0)" line81="            pins.analogWritePin(AnalogPin.P16, -speed2)" line82="        }" line83="        else if (speed2 &gt;= 0) {" line84="            pins.digitalWritePin(DigitalPin.P15, 1)" line85="            pins.analogWritePin(AnalogPin.P16, speed2)" line86="        }" line87="    }" line88="" line89="    //% group=&quot;Motor Control&quot;" line90="    /**" line91="     * Control motor speed 1 channel. The speed motor is adjustable between -100 to 100." line92="     */" line93="    //% block=&quot;motorWrite %Motor_Write|Speed %Speed&quot;" line94="    //% speed.min=-100 speed.max=100" line95="    export function motorWrite(motor: Motor_Write, speed: number): void {" line96="        speed = pins.map(speed, -100, 100, -1023, 1023)" line97="        " line98="        if (motor == Motor_Write.Motor_1) {" line99="            if (speed &lt; 0) {" line100="                pins.digitalWritePin(DigitalPin.P13, 0)" line101="                pins.analogWritePin(AnalogPin.P14, -speed)" line102="            }" line103="            else if (speed &gt;= 0) {" line104="                pins.digitalWritePin(DigitalPin.P13, 1)" line105="                pins.analogWritePin(AnalogPin.P14, speed)" line106="            }" line107="        }" line108="        else if (motor == Motor_Write.Motor_2) {" line109="            if (speed &lt; 0) {" line110="                pins.digitalWritePin(DigitalPin.P15, 0)" line111="                pins.analogWritePin(AnalogPin.P16, -speed)" line112="            }" line113="            else if (speed &gt;= 0) {" line114="                pins.digitalWritePin(DigitalPin.P15, 1)" line115="                pins.analogWritePin(AnalogPin.P16, speed)" line116="            }" line117="        }" line118="    }" line119="" line120="    //% group=&quot;Servo Control&quot;" line121="    /**" line122="     * Control Servo Motor 0 - 180 Degrees" line123="     */" line124="    //% block=&quot;Servo %Servo_Write|Degree %Degree&quot;" line125="    //% degree.min=0 degree.max=180" line126="    export function servoWrite(servo: Servo_Write, degree: number): void {" line127="        if (servo == Servo_Write.P8) {" line128="            pins.servoWritePin(AnalogPin.P8, degree)" line129="        }" line130="        else if (servo == Servo_Write.P12) {" line131="            pins.servoWritePin(AnalogPin.P12, degree)" line132="        }" line133="    }" line134="" line135="    //% group=&quot;ADC and Sensor&quot;" line136="    /**" line137="     * Read Analog from ADC Channel" line138="     */" line139="    //% block=&quot;ADCRead %ADC_Read&quot;" line140="    export function ADCRead(ADCRead:ADC_Read): number { " line141="        pins.i2cWriteNumber(0x48, ADCRead, NumberFormat.UInt8LE, false)" line142="        return ADCRead = pins.i2cReadNumber(0x48, NumberFormat.UInt16BE, false)      " line143="    }" line144="" line145="    //% group=&quot;Line Follower&quot;" line146="    /**" line147="     * Turn Left or Right Follower Line Mode" line148="     */" line149="    //% block=&quot;TurnLINE %turn|Speed\n %speed|Sensor %sensor|Fast Time\n %time|Break Time %break_delay&quot;" line150="    //% speed.min=0 speed.max=100" line151="    //% time.shadow=&quot;timePicker&quot;" line152="    //% break_delay.shadow=&quot;timePicker&quot;" line153="    //% time.defl=200" line154="    //% break_delay.defl=20" line155="    export function TurnLINE(turn: Turn_Line, speed: number, sensor: number, time: number, break_delay: number) {" line156="        let ADC_PIN = [" line157="                ADC_Read.ADC0," line158="                ADC_Read.ADC1," line159="                ADC_Read.ADC2," line160="                ADC_Read.ADC3," line161="                ADC_Read.ADC4," line162="                ADC_Read.ADC5," line163="                ADC_Read.ADC6," line164="                ADC_Read.ADC7" line165="            ]" line166="        let on_line = 0" line167="        let position = pins.map(sensor, 1, Num_Sensor, 0, (Num_Sensor - 1) * 1000)" line168="        let error2 = 0" line169="        let timer = 0" line170="        let motor_speed = 0" line171="        let motor_slow = Math.round(speed / 5)" line172="        while (1) {" line173="            on_line = 0" line174="            for (let i = 0; i &lt; Sensor_PIN.length; i ++) {" line175="                if ((pins.map(ADCRead(ADC_PIN[Sensor_PIN[i]]), Color_Line[i], Color_Background[i], 1000, 0)) &gt;= 800) {" line176="                    on_line += 1;" line177="                }" line178="            }" line179="" line180="            if (on_line == 0) {" line181="                break" line182="            }" line183="" line184="            if (turn == Turn_Line.Left) {" line185="                motorGo(speed, -speed)" line186="            }" line187="            else if (turn == Turn_Line.Right) {" line188="                motorGo(-speed, speed)" line189="            }" line190="        }" line191="        timer = control.millis()" line192="        while (1) {" line193="            if ((Math.abs(position - GETPosition())) &lt;= 100) {" line194="                basic.pause(break_delay)" line195="                motorStop()" line196="                break" line197="            }" line198="            else {" line199="                error2 = timer - (control.millis() - time)" line200="                motor_speed = error2" line201="" line202="                if (motor_speed &gt; 100) {" line203="                    motor_speed = 100" line204="                }" line205="                else if (motor_speed &lt; 0) {" line206="                    motor_speed = motor_slow" line207="                }" line208="" line209="                if (turn == Turn_Line.Left) {" line210="                    motorGo(motor_speed, -motor_speed)" line211="                }" line212="                else if (turn == Turn_Line.Right) {" line213="                    motorGo(-motor_speed, motor_speed)" line214="                }" line215="            }" line216="        }" line217="    }" line218="" line219="    //% group=&quot;Line Follower&quot;" line220="    /**" line221="     * Line Follower Forward Timer" line222="     */" line223="    //% block=&quot;ForwardTIME %time|Min Speed\n\n %base_speed|Max Speed\n\n %max_speed|KP %kp|KD %kd&quot;" line224="    //% min_speed.min=0 min_speed.max=100" line225="    //% max_speed.min=0 max_speed.max=100" line226="    //% time.shadow=&quot;timePicker&quot;" line227="    //% time.defl=200" line228="    export function ForwardTIME(time: number, min_speed: number, max_speed: number, kp: number, kd: number) {" line229="        let timer2 = control.millis()" line230="        while (control.millis() - timer2 &lt; time) {" line231="            error = GETPosition() - (((Num_Sensor - 1) * 1000) / 2)" line232="            P = error" line233="            D = error - previous_error" line234="            PD_Value = (kp * P) + (kd * D)" line235="            previous_error = error" line236="" line237="            left_motor_speed = min_speed + PD_Value" line238="            right_motor_speed = min_speed - PD_Value" line239="" line240="            if (left_motor_speed &gt; max_speed) {" line241="                left_motor_speed = max_speed" line242="            }" line243="            else if (left_motor_speed &lt; -max_speed) {" line244="                left_motor_speed = -max_speed" line245="            }" line246="" line247="            if (right_motor_speed &gt; max_speed) {" line248="                right_motor_speed = max_speed" line249="            }" line250="            else if (right_motor_speed &lt; -max_speed) {" line251="                right_motor_speed = -max_speed" line252="            }" line253="" line254="            motorGo(left_motor_speed, right_motor_speed)" line255="        }" line256="        motorStop()" line257="    }" line258="" line259="    //% group=&quot;Line Follower&quot;" line260="    /**" line261="     * Line Follower Forward" line262="     */" line263="    //% block=&quot;ForwardFIND %Find_Line|Min Speed\n %base_speed|Max Speed\n %max_speed|Break Time %break_time|KP %kp|KD %kd&quot;" line264="    //% min_speed.min=0 min_speed.max=100" line265="    //% max_speed.min=0 max_speed.max=100" line266="    //% break_time.shadow=&quot;timePicker&quot;" line267="    //% break_time.defl=20" line268="    export function ForwardLINE(find: Find_Line, min_speed: number, max_speed: number, break_time: number, kp: number, kd: number) {" line269="        let ADC_PIN2 = [" line270="                ADC_Read.ADC0, " line271="                ADC_Read.ADC1," line272="                ADC_Read.ADC2, " line273="                ADC_Read.ADC3," line274="                ADC_Read.ADC4, " line275="                ADC_Read.ADC5," line276="                ADC_Read.ADC6," line277="                ADC_Read.ADC7" line278="            ]" line279="        let found_left = 0" line280="        let found_right = 0" line281="        let last_left = 0" line282="        let last_right = 0" line283="        let line_state = 0" line284="        let on_line2 = 0" line285="        let on_line_LR = 0" line286="" line287="        while (1) {" line288="            found_left = 0" line289="            found_right = 0" line290="            on_line2 = 0" line291="            on_line_LR = 0" line292="            for (let j = 0; j &lt; Sensor_PIN.length; j ++) {" line293="                if ((pins.map(ADCRead(ADC_PIN2[Sensor_PIN[j]]), Color_Line[j], Color_Background[j], 1000, 0)) &gt;= 800) {" line294="                    on_line2 += 1;" line295="                }" line296="            }" line297="" line298="            for (let k = 0; k &lt; Sensor_Left.length; k ++) {" line299="                if ((pins.map(ADCRead(ADC_PIN2[Sensor_Left[k]]), Color_Line_Left[k], Color_Background[k], 1000, 0)) &gt;= 800) {" line300="                    on_line_LR += 1;" line301="                }" line302="            }" line303="" line304="            for (let l = 0; l &lt; Sensor_Right.length; l ++) {" line305="                if ((pins.map(ADCRead(ADC_PIN2[Sensor_Right[l]]), Color_Line_Right[l], Color_Background[l], 1000, 0)) &gt;= 800) {" line306="                    on_line_LR += 1;" line307="                }" line308="            }" line309="            if (on_line2 &gt; 0 &amp;&amp; on_line2 &lt;= 2 &amp;&amp; on_line_LR == 0) {" line310="                error = GETPosition() - (((Num_Sensor - 1) * 1000) / 2)" line311="                P = error" line312="                D = error - previous_error" line313="                PD_Value = (kp * P) + (kd * D)" line314="                previous_error = error" line315="" line316="                left_motor_speed = min_speed + PD_Value" line317="                right_motor_speed = min_speed - PD_Value" line318="" line319="                if (left_motor_speed &gt; max_speed) {" line320="                    left_motor_speed = max_speed" line321="                }" line322="                else if (left_motor_speed &lt; -max_speed) {" line323="                    left_motor_speed = -max_speed" line324="                }" line325="" line326="                if (right_motor_speed &gt; max_speed) {" line327="                    right_motor_speed = max_speed" line328="                }" line329="                else if (right_motor_speed &lt; -max_speed) {" line330="                    right_motor_speed = -max_speed" line331="                }" line332="" line333="                motorGo(left_motor_speed, right_motor_speed)" line334="            }" line335="            else {" line336="                motorGo(min_speed, min_speed)" line337="            }" line338="" line339="            if (line_state == 0) {" line340="                for (let m = 0; m &lt; Sensor_Left.length; m ++) {" line341="                    if ((pins.map(ADCRead(ADC_PIN2[Sensor_Left[m]]), Color_Line_Left[m], Color_Background[m], 1000, 0)) &gt;= 800) {" line342="                        found_left += 1;" line343="                    }" line344="                }" line345="" line346="                for (let n = 0; n &lt; Sensor_Right.length; n ++) {" line347="                    if ((pins.map(ADCRead(ADC_PIN2[Sensor_Right[n]]), Color_Line_Right[n], Color_Background[n], 1000, 0)) &gt;= 800) {" line348="                        found_right += 1;" line349="                    }" line350="                }" line351="" line352="                if (found_left == Sensor_Left.length || found_right == Sensor_Right.length) {" line353="                    line_state = 1" line354="                }" line355="            }" line356="            else if (line_state == 1) {" line357="                for (let o = 0; o &lt; Sensor_Left.length; o ++) {" line358="                    if ((pins.map(ADCRead(ADC_PIN2[Sensor_Left[o]]), Color_Line_Left[o], Color_Background[o], 1000, 0)) &gt;= 800) {" line359="                        found_left += 1;" line360="                        if (last_left != Sensor_Left.length) {" line361="                            last_left = found_left" line362="                        }" line363="                    }" line364="                }" line365="" line366="                for (let p = 0; p &lt; Sensor_Right.length; p ++) {" line367="                    if ((pins.map(ADCRead(ADC_PIN2[Sensor_Right[p]]), Color_Line_Right[p], Color_Background[p], 1000, 0)) &gt;= 800) {" line368="                        found_right += 1;" line369="                        if (last_right != Sensor_Right.length) {" line370="                            last_right = found_right" line371="                        }" line372="                    }" line373="                }" line374="" line375="                if (found_left != Sensor_Left.length &amp;&amp; found_right != Sensor_Right.length) {" line376="                    line_state = 2" line377="                }" line378="            }" line379="" line380="            else if (line_state == 2) {" line381="                if (find == Find_Line.Left) {" line382="                    if (last_left == Sensor_Left.length &amp;&amp; last_right != Sensor_Right.length) {" line383="                        motorGo(-100, -100)" line384="                        basic.pause(break_time)" line385="                        motorStop()" line386="                        break" line387="                    }" line388="                    else {" line389="                        last_left = 0" line390="                        last_right = 0" line391="                        line_state = 0" line392="                    }" line393="                }" line394="                else if (find == Find_Line.Center) {" line395="                    if (last_left == Sensor_Left.length &amp;&amp; last_right == Sensor_Right.length) {" line396="                        motorGo(-100, -100)" line397="                        basic.pause(break_time)" line398="                        motorStop()" line399="                        break" line400="                    }" line401="                    else {" line402="                        last_left = 0" line403="                        last_right = 0" line404="                        line_state = 0" line405="                    }" line406="                }" line407="                else if (find == Find_Line.Right) {" line408="                    if (last_left != Sensor_Left.length &amp;&amp; last_right == Sensor_Right.length) {" line409="                        motorGo(-100, -100)" line410="                        basic.pause(break_time)" line411="                        motorStop()" line412="                        break" line413="                    }" line414="                    else {" line415="                        last_left = 0" line416="                        last_right = 0" line417="                        line_state = 0" line418="                    }" line419="                }" line420="            }" line421="        }" line422="    }" line423="" line424="    //% group=&quot;Line Follower&quot;" line425="    /**" line426="     * Get Position Line" line427="     */" line428="    //% block=&quot;GETPosition&quot;" line429="    export function GETPosition() {" line430="        let ADC_PIN3 = [" line431="                ADC_Read.ADC0, " line432="                ADC_Read.ADC1," line433="                ADC_Read.ADC2, " line434="                ADC_Read.ADC3," line435="                ADC_Read.ADC4, " line436="                ADC_Read.ADC5," line437="                ADC_Read.ADC6," line438="                ADC_Read.ADC7" line439="            ]" line440="        let Average = 0" line441="        let Sum_Value = 0" line442="        let ON_Line = 0" line443="" line444="        for (let q = 0; q &lt; Num_Sensor; q ++) {" line445="            let Value_Sensor = 0;" line446="            if (Line_Mode == 0) {" line447="                Value_Sensor = pins.map(ADCRead(ADC_PIN3[Sensor_PIN[q]]), Color_Line[q], Color_Background[q], 1000, 0)" line448="                if (Value_Sensor &lt; 0) {" line449="                    Value_Sensor = 0" line450="                }" line451="                else if (Value_Sensor &gt; 1000) {" line452="                    Value_Sensor = 1000" line453="                }" line454="            }" line455="            else {" line456="                Value_Sensor = pins.map(ADCRead(ADC_PIN3[Sensor_PIN[q]]), Color_Background[q], Color_Line[q], 1000, 0)" line457="                if (Value_Sensor &lt; 0) {" line458="                    Value_Sensor = 0" line459="                }" line460="                else if (Value_Sensor &gt; 1000) {" line461="                    Value_Sensor = 1000" line462="                }" line463="            }" line464="            if (Value_Sensor &gt; 200) {" line465="                ON_Line = 1;" line466="                Average += Value_Sensor * (q * 1000)" line467="                Sum_Value += Value_Sensor" line468="            }" line469="        }" line470="        if (ON_Line == 0){" line471="            if (Last_Position &lt; (Num_Sensor - 1) * 1000 / 2){" line472="                return (Num_Sensor - 1) * 1000" line473="            }" line474="            else{" line475="                return 0" line476="            }" line477="        }" line478="        Last_Position = Average / Sum_Value;" line479="        return Math.round(((Num_Sensor - 1) * 1000) - Last_Position)" line480="    }" line481="" line482="    //% group=&quot;Line Follower&quot;" line483="    /**" line484="     * Calibrate Line Sensor" line485="     */" line486="    //% block=&quot;LINECalibrate&quot;" line487="    export function LINECalibrate():void {" line488="        let ADC_PIN4 = [ " line489="                ADC_Read.ADC0," line490="                ADC_Read.ADC1," line491="                ADC_Read.ADC2," line492="                ADC_Read.ADC3," line493="                ADC_Read.ADC4," line494="                ADC_Read.ADC5," line495="                ADC_Read.ADC6," line496="                ADC_Read.ADC7" line497="            ]" line498="        let Line_Cal = [0, 0, 0, 0, 0, 0, 0, 0]" line499="        let Line_Cal_L = [0, 0, 0, 0, 0, 0, 0, 0]" line500="        let Line_Cal_R = [0, 0, 0, 0, 0, 0, 0, 0]" line501="        let Background_Cal = [0, 0, 0, 0, 0, 0, 0, 0]" line502="" line503="        music.playTone(587, music.beat(BeatFraction.Quarter))" line504="        music.playTone(784, music.beat(BeatFraction.Quarter))" line505="        ////Calibrate Follower Line" line506="        while (!input.buttonIsPressed(Button.A));" line507="        music.playTone(784, music.beat(BeatFraction.Quarter))" line508="        for (let r = 0; r &lt; 20; r ++) {" line509="            for (let s = 0; s &lt; Num_Sensor; s ++) {" line510="                Line_Cal[s] += ADCRead(ADC_PIN4[Sensor_PIN[s]])" line511="            }" line512="            basic.pause(50)" line513="        }" line514="        for (let t = 0; t &lt; Num_Sensor; t ++) {" line515="            Line_Cal[t] = Line_Cal[t] / 20" line516="            Color_Line[t] = Line_Cal[t]" line517="        }" line518="" line519="        music.playTone(784, music.beat(BeatFraction.Quarter))" line520="        ////Calibrate LR Line" line521="        while (!input.buttonIsPressed(Button.A));" line522="        music.playTone(784, music.beat(BeatFraction.Quarter))" line523="        for (let u = 0; u &lt; 20; u ++) {" line524="            for (let v = 0; v &lt; Sensor_Left.length; v ++) {" line525="                Line_Cal_L[v] += ADCRead(ADC_PIN4[Sensor_Left[v]])" line526="            }" line527="            for (let w = 0; w &lt; Sensor_Right.length; w ++) {" line528="                Line_Cal_R[w] += ADCRead(ADC_PIN4[Sensor_Right[w]])" line529="            }" line530="            basic.pause(50)" line531="        }" line532="        for (let a = 0; a &lt; Sensor_Left.length; a ++) {" line533="            Line_Cal_L[a] = Line_Cal_L[a] / 20" line534="            Color_Line_Left[a] = Line_Cal_L[a]" line535="        }" line536="        for (let b = 0; b &lt; Sensor_Right.length; b ++) {" line537="            Line_Cal_R[b] = Line_Cal_R[b] / 20" line538="            Color_Line_Right[b] = Line_Cal_R[b]" line539="        }" line540="" line541="        music.playTone(784, music.beat(BeatFraction.Quarter))" line542="        ////Calibrate Background" line543="        while (!input.buttonIsPressed(Button.A));" line544="        music.playTone(784, music.beat(BeatFraction.Quarter))" line545="        for (let c = 0; c &lt; 20; c ++) {" line546="            for (let d = 0; d &lt; Num_Sensor; d ++) {" line547="                Background_Cal[d] += ADCRead(ADC_PIN4[Sensor_PIN[d]])" line548="            }" line549="            basic.pause(50)" line550="        }" line551="        for (let e = 0; e &lt; Num_Sensor; e ++) {" line552="            Background_Cal[e] = Background_Cal[e] / 20" line553="            Color_Background[e] = Background_Cal[e]" line554="        }" line555="        music.playTone(784, music.beat(BeatFraction.Quarter))" line556="        music.playTone(587, music.beat(BeatFraction.Quarter))" line557="    }" line558="" line559="    //% group=&quot;Line Follower&quot;" line560="    /**" line561="     * Set Line Sensor Pin" line562="     */" line563="    //% block=&quot;LINESensorSET $adc_pin|Sensor Left\n\n $sensor_left|Sensor Right\n $sensor_right|ON OFF Sensor $led_pin&quot;" line564="    export function LINESensorSET(adc_pin: number[], sensor_left: number[], sensor_right: number[], led_pin: LED_Pin): void {" line565="        Sensor_PIN = adc_pin" line566="        Sensor_Left = sensor_left" line567="        Sensor_Right = sensor_right" line568="        Num_Sensor = Sensor_PIN.length" line569="        LED_PIN = led_pin" line570="    }" line571="}" numlines="572"></mutation></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></statement></block></xml>